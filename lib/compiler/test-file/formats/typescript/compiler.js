"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const typescript_configuration_1 = __importDefault(require("../../../../configuration/typescript-configuration"));
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', api_based_1.default.EXPORTABLE_LIB_PATH]]);
class TypeScriptTestFileCompiler extends api_based_1.default {
    constructor(compilerOptions = {}) {
        super();
        const tsConfigPath = compilerOptions.typeScriptOptions ? compilerOptions.typeScriptOptions.tsConfigPath : null;
        this.tsConfig = new typescript_configuration_1.default(tsConfigPath);
    }
    static _normalizeFilename(filename) {
        filename = path_1.default.resolve(filename);
        if (os_family_1.default.win)
            filename = filename.toLowerCase();
        return filename;
    }
    static _getTSDefsPath() {
        return TypeScriptTestFileCompiler._normalizeFilename(path_1.default.resolve(__dirname, '../../../../../ts-defs/index.d.ts'));
    }
    static _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        let errMsg = 'TypeScript compilation failed.\n';
        diagnostics.forEach(d => {
            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
            const file = d.file;
            if (file && d.start !== void 0) {
                const { line, character } = file.getLineAndCharacterOfPosition(d.start);
                errMsg += `${file.fileName} (${line + 1}, ${character + 1}): `;
            }
            errMsg += `${message}\n`;
        });
        throw new Error(errMsg);
    }
    _compileCodeForTestFiles(testFilesInfo) {
        return this.tsConfig.init()
            .then(() => {
            return super._compileCodeForTestFiles(testFilesInfo);
        });
    }
    _compileFilesToCache(ts, filenames) {
        const opts = this.tsConfig.getOptions();
        const program = ts.createProgram([TypeScriptTestFileCompiler.tsDefsPath, ...filenames], opts);
        program.getSourceFiles().forEach(sourceFile => {
            // @ts-ignore A hack to allow import globally installed TestCafe in tests
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length)
            TypeScriptTestFileCompiler._reportErrors(diagnostics);
        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            if (!sources)
                return;
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
            this.cache[sourcePath] = result;
        });
    }
    _precompileCode(testFilesInfo) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        const filenames = testFilesInfo.map(({ filename }) => filename);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
        const uncachedFiles = normalizedFilenames
            .filter(filename => filename !== TypeScriptTestFileCompiler.tsDefsPath && !this.cache[filename])
            .map(filename => normalizedFilenamesMap[filename]);
        if (uncachedFiles.length)
            this._compileFilesToCache(ts, uncachedFiles);
        return normalizedFilenames.map(filename => this.cache[filename]);
    }
    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename)
        };
    }
    get canPrecompile() {
        return true;
    }
    getSupportedExtension() {
        return '.ts';
    }
}
TypeScriptTestFileCompiler.tsDefsPath = TypeScriptTestFileCompiler._getTSDefsPath();
exports.default = TypeScriptTestFileCompiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFDekQsa0hBQXlGO0FBMkJ6RixNQUFNLHdCQUF3QixHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsbUJBQTRCLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFM0csTUFBcUIsMEJBQTJCLFNBQVEsbUJBQTRCO0lBS2hGLFlBQW9CLGtCQUFtQyxFQUFFO1FBQ3JELEtBQUssRUFBRSxDQUFDO1FBRVIsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFL0csSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGtDQUF1QixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFTyxNQUFNLENBQUMsa0JBQWtCLENBQUUsUUFBZ0I7UUFDL0MsUUFBUSxHQUFHLGNBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFbEMsSUFBSSxtQkFBRSxDQUFDLEdBQUc7WUFDTixRQUFRLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXRDLE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFFTyxNQUFNLENBQUMsY0FBYztRQUN6QixPQUFPLDBCQUEwQixDQUFDLGtCQUFrQixDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLG1DQUFtQyxDQUFDLENBQUMsQ0FBQztJQUN2SCxDQUFDO0lBRU8sTUFBTSxDQUFD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QWlIQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgemlwT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBPUyBmcm9tICdvcy1mYW1pbHknO1xuaW1wb3J0IEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2UgZnJvbSAnLi4vLi4vYXBpLWJhc2VkJztcbmltcG9ydCBFU05leHRUZXN0RmlsZUNvbXBpbGVyIGZyb20gJy4uL2VzLW5leHQvY29tcGlsZXInO1xuaW1wb3J0IFR5cGVzY3JpcHRDb25maWd1cmF0aW9uIGZyb20gJy4uLy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vdHlwZXNjcmlwdC1jb25maWd1cmF0aW9uJztcblxuLy8gTk9URTogRm9yIHR5cGUgZGVmaW5pdGlvbnMgb25seVxuaW1wb3J0IFR5cGVTY3JpcHQsIHsgQ29tcGlsZXJPcHRpb25zVmFsdWUgfSBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25maWd1cmF0aW9uL2ludGVyZmFjZXMnO1xuXG5cbmRlY2xhcmUgdHlwZSBUeXBlU2NyaXB0SW5zdGFuY2UgPSB0eXBlb2YgVHlwZVNjcmlwdDtcblxuaW50ZXJmYWNlIENvbXBpbGVyT3B0aW9ucyB7XG4gICAgdHlwZVNjcmlwdE9wdGlvbnM/OiB7XG4gICAgICAgIHRzQ29uZmlnUGF0aDogc3RyaW5nO1xuICAgIH07XG59XG5cbmludGVyZmFjZSBUZXN0RmlsZUluZm8ge1xuICAgIGZpbGVuYW1lOiBzdHJpbmc7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIFJlcXVpcmVDb21waWxlckZ1bmN0aW9uIHtcbiAgICAoY29kZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVxdWlyZUNvbXBpbGVycyB7XG4gICAgW2V4dGVuc2lvbjogc3RyaW5nXTogUmVxdWlyZUNvbXBpbGVyRnVuY3Rpb247XG59XG5cbmNvbnN0IFJFTkFNRURfREVQRU5ERU5DSUVTX01BUCA9IG5ldyBNYXAoW1sndGVzdGNhZmUnLCBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlLkVYUE9SVEFCTEVfTElCX1BBVEhdXSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyIGV4dGVuZHMgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgdHNEZWZzUGF0aCA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUU0RlZnNQYXRoKCk7XG5cbiAgICBwcml2YXRlIHRzQ29uZmlnOiBUeXBlc2NyaXB0Q29uZmlndXJhdGlvbjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoY29tcGlsZXJPcHRpb25zOiBDb21waWxlck9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGNvbnN0IHRzQ29uZmlnUGF0aCA9IGNvbXBpbGVyT3B0aW9ucy50eXBlU2NyaXB0T3B0aW9ucyA/IGNvbXBpbGVyT3B0aW9ucy50eXBlU2NyaXB0T3B0aW9ucy50c0NvbmZpZ1BhdGggOiBudWxsO1xuXG4gICAgICAgIHRoaXMudHNDb25maWcgPSBuZXcgVHlwZXNjcmlwdENvbmZpZ3VyYXRpb24odHNDb25maWdQYXRoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfbm9ybWFsaXplRmlsZW5hbWUgKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBmaWxlbmFtZSA9IHBhdGgucmVzb2x2ZShmaWxlbmFtZSk7XG5cbiAgICAgICAgaWYgKE9TLndpbilcbiAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2dldFRTRGVmc1BhdGggKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uLy4uLy4uLy4uL3RzLWRlZnMvaW5kZXguZC50cycpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfcmVwb3J0RXJyb3JzIChkaWFnbm9zdGljczogUmVhZG9ubHk8VHlwZVNjcmlwdC5EaWFnbm9zdGljW10+KTogdm9pZCB7XG4gICAgICAgIC8vIE5PVEU6IGxhenkgbG9hZCB0aGUgY29tcGlsZXJcbiAgICAgICAgY29uc3QgdHM6IFR5cGVTY3JpcHRJbnN0YW5jZSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcbiAgICAgICAgbGV0IGVyck1zZyA9ICdUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZC5cXG4nO1xuXG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdHMuZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkLm1lc3NhZ2VUZXh0LCAnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBmaWxlICAgID0gZC5maWxlO1xuXG4gICAgICAgICAgICBpZiAoZmlsZSAmJiBkLnN0YXJ0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxpbmUsIGNoYXJhY3RlciB9ID0gZmlsZS5nZXRMaW5lQW5kQ2hhcmFjdGVyT2ZQb3NpdGlvbihkLnN0YXJ0KTtcblxuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgJHtmaWxlLmZpbGVOYW1lfSAoJHtsaW5lICsgMX0sICR7Y2hhcmFjdGVyICsgMX0pOiBgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJNc2cgKz0gYCR7bWVzc2FnZX1cXG5gO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgX2NvbXBpbGVDb2RlRm9yVGVzdEZpbGVzICh0ZXN0RmlsZXNJbmZvOiBUZXN0RmlsZUluZm9bXSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNDb25maWcuaW5pdCgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jb21waWxlQ29kZUZvclRlc3RGaWxlcyh0ZXN0RmlsZXNJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NvbXBpbGVGaWxlc1RvQ2FjaGUgKHRzOiBUeXBlU2NyaXB0SW5zdGFuY2UsIGZpbGVuYW1lczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgb3B0cyAgICA9IHRoaXMudHNDb25maWcuZ2V0T3B0aW9ucygpIGFzIERpY3Rpb25hcnk8Q29tcGlsZXJPcHRpb25zVmFsdWU+O1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gdHMuY3JlYXRlUHJvZ3JhbShbVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIudHNEZWZzUGF0aCwgLi4uZmlsZW5hbWVzXSwgb3B0cyk7XG5cbiAgICAgICAgcHJvZ3JhbS5nZXRTb3VyY2VGaWxlcygpLmZvckVhY2goc291cmNlRmlsZSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIEEgaGFjayB0byBhbGxvdyBpbXBvcnQgZ2xvYmFsbHkgaW5zdGFsbGVkIFRlc3RDYWZlIGluIHRlc3RzXG4gICAgICAgICAgICBzb3VyY2VGaWxlLnJlbmFtZWREZXBlbmRlbmNpZXMgPSBSRU5BTUVEX0RFUEVOREVOQ0lFU19NQVA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0gdHMuZ2V0UHJlRW1pdERpYWdub3N0aWNzKHByb2dyYW0pO1xuXG4gICAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGgpXG4gICAgICAgICAgICBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fcmVwb3J0RXJyb3JzKGRpYWdub3N0aWNzKTtcblxuICAgICAgICAvLyBOT1RFOiBUaGUgZmlyc3QgYXJndW1lbnQgb2YgZW1pdCgpIGlzIGEgc291cmNlIGZpbGUgdG8gYmUgY29tcGlsZWQuIElmIGl0J3MgdW5kZWZpbmVkLCBhbGwgZmlsZXMgaW5cbiAgICAgICAgLy8gPHByb2dyYW0+IHdpbGwgYmUgY29tcGlsZWQuIDxwcm9ncmFtPiBjb250YWlucyBhIGZpbGUgc3BlY2lmaWVkIGluIGNyZWF0ZVByb2dyYW0oKSBwbHVzIGFsbCBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAvLyBUaGlzIG1vZGUgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjb21waWxpbmcgZmlsZXMgb25lLWJ5LW9uZSwgYW5kIGl0IGlzIHVzZWQgaW4gdGhlIHRzYyBDTEkgY29tcGlsZXIuXG4gICAgICAgIHByb2dyYW0uZW1pdCh2b2lkIDAsIChvdXRwdXROYW1lLCByZXN1bHQsIHdyaXRlQk9NLCBvbkVycm9yLCBzb3VyY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQYXRoID0gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX25vcm1hbGl6ZUZpbGVuYW1lKHNvdXJjZXNbMF0uZmlsZU5hbWUpO1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlW3NvdXJjZVBhdGhdID0gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgX3ByZWNvbXBpbGVDb2RlICh0ZXN0RmlsZXNJbmZvOiBUZXN0RmlsZUluZm9bXSk6IHN0cmluZ1tdIHtcbiAgICAgICAgLy8gTk9URTogbGF6eSBsb2FkIHRoZSBjb21waWxlclxuICAgICAgICBjb25zdCB0czogVHlwZVNjcmlwdEluc3RhbmNlID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lcyAgICAgICAgICAgICAgPSB0ZXN0RmlsZXNJbmZvLm1hcCgoeyBmaWxlbmFtZSB9KSA9PiBmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXMgICAgPSBmaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWVzTWFwID0gemlwT2JqZWN0KG5vcm1hbGl6ZWRGaWxlbmFtZXMsIGZpbGVuYW1lcyk7XG5cbiAgICAgICAgY29uc3QgdW5jYWNoZWRGaWxlcyA9IG5vcm1hbGl6ZWRGaWxlbmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gZmlsZW5hbWUgIT09IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLnRzRGVmc1BhdGggJiYgIXRoaXMuY2FjaGVbZmlsZW5hbWVdKVxuICAgICAgICAgICAgLm1hcChmaWxlbmFtZSA9PiBub3JtYWxpemVkRmlsZW5hbWVzTWFwW2ZpbGVuYW1lXSk7XG5cbiAgICAgICAgaWYgKHVuY2FjaGVkRmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZUZpbGVzVG9DYWNoZSh0cywgdW5jYWNoZWRGaWxlcyk7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IHRoaXMuY2FjaGVbZmlsZW5hbWVdKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgX2dldFJlcXVpcmVDb21waWxlcnMgKCk6IFJlcXVpcmVDb21waWxlcnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJy50cyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy5qcyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gRVNOZXh0VGVzdEZpbGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb2RlLmNhbGwodGhpcywgY29kZSwgZmlsZW5hbWUpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBjYW5QcmVjb21waWxlICgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFN1cHBvcnRlZEV4dGVuc2lvbiAoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICcudHMnO1xuICAgIH1cbn1cbiJdfQ==